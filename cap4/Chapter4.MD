# Cap√≠tulo 4:  Baking with OO Goodness: the Factory Pattern

# Factory Pattern | Creacional

Idea central:
El Factory abstrae la creaci√≥n de objetos, delegando la responsabilidad a un m√©todo o clase especial. As√≠, el c√≥digo cliente no necesita conocer los detalles de construcci√≥n ni las clases concretas, solo la interfaz com√∫n.

‚úÖ Pros

- Encapsula la creaci√≥n: el cliente no depende de constructores concretos.

- Menos acoplamiento: puedes cambiar la clase concreta sin modificar el resto del sistema.

- Reutilizaci√≥n de l√≥gica de instanciaci√≥n: centralizas validaciones, configuraci√≥n inicial o caching.

- Escalabilidad: facilita agregar nuevas variantes sin romper el c√≥digo cliente.

‚ùå Contras

- Complejidad extra: a√±ade una capa m√°s de abstracci√≥n (puede ser overkill en sistemas simples).

- Dif√≠cil rastrear instancias: a veces cuesta seguir qu√© clase concreta devolvi√≥ la f√°brica.

- Abuso com√∫n: usar factories innecesariamente puede ensuciar el dise√±o.


## Recomendaciones transversales

### Usar Decorator cuando

- Necesitas a√±adir responsabilidades din√°micamente a objetos/servicios sin modificar su c√≥digo.

- Quiere evitar explosi√≥n de subclases (combinaciones de comportamientos).

- Buscas composici√≥n modular y reutilizable de comportamientos.

### Evitar Decorator cuando

- El orden de aplicaci√≥n es cr√≠tico y complejo (puede introducir bugs sutiles).

- La funcionalidad podr√≠a resolverse con una simple composici√≥n de funciones o configuraci√≥n (overengineering).

- Necesitas transaccionalidad at√≥mica entre pasos; decorator por s√≠ solo no garantiza consistencia.

### Riesgos y mitigaciones

- Debugging: instrumenta la cadena de decoradores (trace ids, logs).

- Anidamiento excesivo: limita combinaciones habituales; documenta patrones soportados.

- Fugas de rendimiento: mide latencia a√±adida y lazy-load donde convenga.

- Incompatibilidades: estandariza inputs/outputs para evitar que decoradores se ‚Äúpisen‚Äù.

## Ejemplos empresariales

#### 1) Autenticaci√≥n / Seguridad ‚Äî AuthFactory (JWT | OAuth | SAML)

- Requisitos y alcance: define qu√© flujos necesitas (login, refresh, logout, introspect, revocation) y qu√© responsabilidades tendr√° el factory vs el backend.

- Contrato (interface): escribe la API com√∫n que deben exponer las implementaciones (p. ej. authenticate(), validateToken(), getUserClaims(), refresh()).

- Mapa de proveedores: enumera proveedores soportados (Cognito, AzureAD, Keycloak, SAML provider X). Documenta diferencias (claims, lifetime, scopes).

- Implementaciones concretas: por cada proveedor, define la clase que implementa el contrato, encapsulando detalles (endpoints, JWKS, scopes).

- Selecci√≥n de implementaci√≥n: define la l√≥gica para elegir la impl ‚Äî por configuraci√≥n (env var), por tenant (multitenancy), o por discovery din√°mico (metadata URL).

- Configuraci√≥n y secretos: centraliza client IDs, secretos, endpoints en un store seguro (vault/secret manager). No incluyas secretos en config en claro.

- Fallback y errores: define comportamiento cuando la elecci√≥n falla (fallback a provider por defecto, mensajes claros, logging).

- Integraci√≥n backend/frontend: decide qu√© validaciones se realizan en backend y cu√°les en frontend; el factory suele usarse server-side o en un service de BFF.

- Tests & mocks: crea tests unitarios para cada strategy y tests de integraci√≥n con entornos sandbox de los IdP (o mocks con JWKS).

- Observabilidad: m√©tricas de latencia/errores por provider, y logging de auditor√≠a (intentos de login, revocations).

- Documentaci√≥n y on-boarding: explica c√≥mo a√±adir un nuevo provider (qu√© archivos/metadata se necesita).

#### 2) Conexi√≥n a bases de datos ‚Äî ConnectionFactory (Postgres | MongoDB | DynamoDB)

- Definir contrato de acceso: qu√© operaciones m√≠nimas debe soportar la conexi√≥n (pooling, getConnection, close, healthCheck).

- Inventario de DBs: lista de motores y requisitos (drivers, connection string, pooling, transacciones).

- Configuraci√≥n multi-tenant: decide si la f√°brica recibe un tenant-key y mapea a una DB distinta por tenant/config.

- Implementaciones concretas: encapsula l√≥gica espec√≠fica: pool config, timeouts, retry policy, transacciones.

- Pooling y lifecycle: centraliza el pool en la instancia factory y previene creaci√≥n excesiva de conexiones.

- Selector din√°mico: regla de selecci√≥n por env/tenant/feature flag; soporte para cambiar en runtime si es necesario.

- Health checks y fallback: implementa checks peri√≥dicos y estrategia de fallback (read-replica, cache, degraded mode).

- Seguridad: manejo seguro de credenciales y rotaci√≥n. Usa IAM roles si aplica (RDS, Dynamo).

- M√©tricas y tracing: instrumenta latencia, pool usage, errores y queries lentas.

- Testing: mocks de drivers, pruebas de integraci√≥n con contenedores (testcontainers) y pruebas de failover.

- Documentaci√≥n operativa: c√≥mo escalar pools, qu√© tunables ajustar en picos, y runbook para DB failover.

#### 3) Procesadores de pago ‚Äî PaymentFactory (Stripe | PayPal | MercadoPago)

- Requisitos legales y de negocio: flow de pagos (one-time, suscripci√≥n, reembolsos), compliance PCI, monedas soportadas.

- Contrato de alto nivel: m√©todos esenciales (charge, authorize, refund, webhookHandler, getTransactionStatus).

- Implementaciones por provider: encapsula endpoints, webhooks, idempotency keys, y diferencias de modelos (tokens, customers).

- Configuraci√≥n y seguridad: almacena claves en vault; gestiona entornos (sandbox vs production).

- Manejo de webhooks: cada provider firma webhooks distinto ‚Üí las impl deben validar y normalizar eventos.

- Idempotencia y retries: estandariza comportamiento (reintentos, idempotency keys) para evitar cargos dobles.

- Selector de provider: por pa√≠s, preferencia del usuario, costo de transacci√≥n, o fallback si un provider falla.

- Reconciliaci√≥n y reporting: logs y export para reconciliaci√≥n contable; mapea c√≥digos de errores del provider a tu dominio.

- Tests end-to-end: usa entornos sandbox y simuladores de fallos (declined card, network errors).

- Observabilidad y alerting: m√©tricas de √©xito/fracaso, latencia y alertas de volumen an√≥malo.

- Pol√≠tica de rollback y contabilidad: define c√≥mo manejar reembolsos, contracargos y disputas.

#### 4) Gesti√≥n de documentos ‚Äî ReportFactory (PDF | Excel | HTML)

- Requisitos de output: formatos, plantillas, internacionalizaci√≥n, accesibilidad, watermarking, y tama√±os de archivo m√°ximos.

- Contrato de generaci√≥n: m√©todos (render(data): Buffer | Stream, preview, paginate, attachWatermark).

- Implementaciones concretas: librer√≠as/servicios para PDF (wkhtmltopdf, Puppeteer), Excel (xlsx), HTML templating.

- Plantillas y assets: centraliza templates, fuentes, estilos y recursos (logos) en un repo/versionado.

- Selector de formato: regla por petici√≥n de usuario, configuraci√≥n por cliente o por tipo de reporte.

- Streaming y performance: soporta streams para archivos grandes, generaci√≥n as√≠ncrona y cola (background jobs).

- Cach√© y pre-generaci√≥n: cachea reports para consultas repetidas; invalida cach√© por cambios en datos.

- Seguridad y privacidad: enmascarado de datos sensibles, control de acceso a reports pre-generados.

- Testing visual: tests que comparen snapshots visuales y validen estructura (headers, columnas).

- Entrega y almacenamiento: decide S3/Blob y firma URLs para descarga segura.

- Auditor√≠a y trazabilidad: log de qui√©n gener√≥ qu√© y cu√°ndo (necesario en entornos regulatorios).

#### 5) Frontends (Angular/UX) ‚Äî WidgetFactory (componentes din√°micos)

- Requisitos UX: inventario de widgets, props esperadas, responsabilidad (render-only vs widgets con l√≥gica).

- Contrato/Descriptor: define el descriptor que identifica un widget (tipo, versi√≥n, config schema).

- Implementaciones (registry): cada widget implementa la interfaz/component API esperada; register them in a registry.

- Selector y orquestaci√≥n: regla que mapea rol/feature flag/config del tenant a una lista de widgets.

- Carga din√°mica: decide si usar lazy-loading (dynamic imports / module federation) para optimizar bundle size.

- Config-driven: widgets deben aceptar config serializable (JSON) para personalizaci√≥n sin deploy.

- Seguridad y sandboxing: evita ejecutar l√≥gica no confiable; restringe data-binding a props permitidas.

- Testing de integraci√≥n: snapshot tests y pruebas visuales; tests de compatibilidad entre versiones de widget.

- Observabilidad UX: m√©tricas de uso por widget, errores y rendimiento de render.

- Versionado y backward-compat: strategy para desplegar nuevas versiones sin romper consumidores.

- Documentaci√≥n runtime: editor/configurator para product owners que armen dashboards con widgets.

>### üìå Regla de oro
>
> Usa Factory cuando quieras desacoplar el qu√© del c√≥mo.
El cliente pide un objeto, pero no sabe ni le importa de qu√© clase concreta viene.