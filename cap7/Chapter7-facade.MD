

# PatrÃ³n Facade | Estructural

Ofrece una interfaz simple y unificada a un subsistema complejo. La fachada (facade) oculta la complejidad y coordina llamadas a mÃºltiples componentes internos para que el cliente vea una API sencilla.

**âœ… Pros**

- Simplicidad para el cliente: reduce el surface area que otros equipos deben aprender.
- Desacoplamiento: clientes dependen de la fachada, no de mÃºltiples clases internas.
- Encapsula complejidad y polÃ­ticas de orquestaciÃ³n.
- Facilita evoluciÃ³n interna: puedes refactorizar subsistemas sin afectar clientes que usan la fachada.
- Buenas para BFF / anti-corruption layers en integraciones.

**âŒ Contras**

- Puede volverse God Object: si la fachada crece y concentra demasiada lÃ³gica.
- Oculta poder/funcionalidad fina: clientes pierden acceso a funcionalidades avanzadas del subsistema.
- Otra capa de cÃ³digo que mantener; riesgo de duplicar lÃ³gica si no se diseÃ±a bien.
- No elimina la complejidad interna, solo la oculta; problemas subyacentes siguen ahÃ­.

ðŸ“Œ CuÃ¡ndo usarlo

- Cuando quieras simplificar la API que otros mÃ³dulos usan.
- Para encapsular mÃºltiples integraciones (3rd party APIs) detrÃ¡s de una sola cara.
- Cuando necesitas BFF / Anti-Corruption Layer entre dominios.
- Para exponer un API estable mientras refactorizas internamente.

**ðŸš« CuÃ¡ndo no usarlo**

- Si necesitas acceso directo y frecuente a capacidades detalladas del subsistema.
- Si la fachada solo hace passthrough sin coordinar nada â€” sobra la capa.
- No usar como excusa para meter lÃ³gica de negocio compleja; esa lÃ³gica deberÃ­a vivir en servicios/capas apropiadas.

## Ejemplos empresariales 

### 1) BFF (Backend For Frontend) para un portal de clientes

**QuÃ© resuelve:** Unifica mÃºltiples microservicios (perfil, pedidos, facturaciÃ³n, recomendaciones) y presenta un endpoint simple optimizado para la UI.

#### ImplementaciÃ³n â€” pasos

- Definir contratos de datos necesarios por la UI (payloads y shape).
- Crear la fachada BFF que coordina llamadas a microservicios, agrega/transforma datos y maneja cachÃ©/aggregation.
- Implementar resiliencia (timeouts, retries, circuit breakers) en la fachada.
- Capa de seguridad: validar tokens, escopos y sanitizar respuestas.
- Tests E2E con la UI: validar formatos y tiempos.
- Monitoreo: latencia por endpoint y Ã©xito de agregaciones.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar
- Usar cuando mÃºltiples servicios deben combinarse para un flujo UI y quieres optimizar payload/latencia.
- Evitar si la UI sÃ³lo necesita datos de un servicio o si agregas demasiada lÃ³gica de negocio en el BFF.

#### Recomendaciones

- MantÃ©n la fachada delgada: solo orquestaciÃ³n y composiciÃ³n; evita lÃ³gica de negocio compleja.
- Versiona la API del BFF y documenta shapes para frontend.

### 2) Facade para integraciÃ³n con mÃºltiples proveedores de pago

**QuÃ© resuelve:** Oculta las diferencias entre Stripe, PayPal, MercadoPago, presentando una API Ãºnica (charge, refund, webhookHandler).

#### ImplementaciÃ³n â€” pasos

- Definir interfaz comÃºn de pagos (authorize, capture, refund, webhookValidate).
- Implementar adaptadores/clients para cada proveedor.
- Crear la fachada que selecciona adaptador por config/tenant y normaliza respuestas/errores.
- Manejar idempotency, logs y reconciliaciÃ³n en la fachada.
- Tests con sandboxes y simuladores de fallo.
- Monitoreo y alertas por tasa de error por proveedor.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar
- Usar si se integra con varios proveedores y quieres centralizar la lÃ³gica de selecciÃ³n y normalizaciÃ³n.
- Evitar si la integraciÃ³n es con un Ãºnico proveedor y no hay planes de expansiÃ³n.

#### Recomendaciones

- La fachada debe exponer errores normalizados y cÃ³digos de negocio, no los detalles raw del proveedor.
- MantÃ©n adaptadores separados y registrados dinÃ¡micamente para facilitar aÃ±adir nuevos proveedores.

### 3) Facade de orquestaciÃ³n para generaciÃ³n de reportes

**QuÃ© resuelve:** Coordina extracciÃ³n de datos, renderizado (PDF/Excel/HTML), watermarking y almacenamiento en S3, exponiendo un generateReport(params) simple.

#### ImplementaciÃ³n â€” pasos

- Mapear pipeline de generaciÃ³n (fetch â†’ transform â†’ render â†’ store).
- Implementar servicios individuales y un facade que orquesta el flujo y maneja retries/queues.
- Soportar generaciÃ³n sÃ­ncrona corta y asÃ­ncrona (job queue) para heavy reports.
- Exponer endpoint Ãºnico que devuelve estado/URL (o stream si es inmediato).
- Tests de performance y validaciÃ³n de output.
- Logs y trazabilidad por request id.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar cuando la generaciÃ³n implica varios pasos y sistemas externos y quieres una API unificada.
- Evitar para reports triviales que no necesitan orquestaciÃ³n ni persistencia.

#### Recomendaciones

- Implementa colas para reports pesados y haz que la fachada devuelva un job id.
- MantÃ©n trazabilidad clara para reproducir/reportar fallos.

### 4) Facade como Anti-Corruption Layer entre sistemas legados y nuevo dominio

**QuÃ© resuelve:** Traduce y adapta modelos/contratos entre un sistema legacy (ERP) y tus microservicios modernos, evitando contaminar el dominio nuevo con malas prÃ¡cticas del legacy.

#### ImplementaciÃ³n â€” pasos

- Identificar discrepancias de modelo, unidades, reglas de negocio y edge-cases del legacy.
- DiseÃ±ar adaptadores que transformen requests/responses entre mundos.
- Implementar la fachada que expone la API limpia del nuevo dominio y usa adaptadores internamente.
- AÃ±adir validaciones y saneamiento (data massaging) en la fachada.
- Tests de migraciÃ³n y casos de datos sucios.
- Monitorizar diferencias y mÃ©tricas de mapping/errores.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar cuando integras con sistemas que tienen modelos conflictivos y quieres proteger tu dominio.
- Evitar si ambos sistemas comparten el mismo modelo y no hay deuda tÃ©cnica que esconder.

#### Recomendaciones

- Encapsula toda la lÃ³gica de mapping en la fachada/adapter; nunca pierdas el control del modelo del nuevo dominio.
- Documenta transformaciones para auditorÃ­a.

### 5) Facade para subsistema de autenticaciÃ³n y autorizaciÃ³n

**QuÃ© resuelve:** Unifica llamadas a Cognito/Keycloak/LDAP/IDP internas y a policy engines (OPA), exponiendo mÃ©todos simples login, validateToken, getEffectivePermissions.

#### ImplementaciÃ³n â€” pasos

- Definir contrato pÃºblico (login, refresh, introspect, logout, permissions).
- Implementar adaptadores a IdPs y a la capa de polÃ­ticas.
- Crear la fachada que centraliza token validation, caching de metadata JWKS y resoluciÃ³n de permisos (merge de groups/roles).
- AÃ±adir caching, rate-limits y protecciÃ³n frente a ataques (brute force).
- Tests de seguridad con tokens vÃ¡los/invÃ¡lidos y expirados.
- Monitoreo de autenticaciones fallidas y latencia de introspect.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar cuando tienes mÃºltiples IdPs o necesitas una API consistente para toda la plataforma.
- Evitar si tu sistema usa un Ãºnico IdP y no requiere normalizaciÃ³n.

#### Recomendaciones

- No implementes autorizaciÃ³n sensible sÃ³lo en la fachada cliente; la fachada debe ayudar a la UI y BFF, pero la autorizaciÃ³n final la aplica el backend/servicio de recursos.
- MantÃ©n JWKS/config reload automÃ¡tico y manejo seguro de secretos.

### Recomendaciones transversales al usar Facade

> - DiseÃ±a la fachada para casos de uso concretos, no como â€œtodo en unoâ€.
> - MantÃ©n la facade delgada: coordinaciÃ³n y simplificaciÃ³n, no lÃ³gica de negocio compleja.
> - Si la fachada crece mucho, re-particiona en fachadas mÃ¡s pequeÃ±as por dominio/Ã¡mbito.
> - Documenta claramente quÃ© hace la fachada y quÃ© API interna todavÃ­a existe (para uso avanzado).
> - Versiona la fachada para evitar romper consumidores al evolucionar.