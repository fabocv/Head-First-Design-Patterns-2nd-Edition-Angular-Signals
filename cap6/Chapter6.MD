# Cap√≠tulo 6: Encapsulating Invocation: the Command Pattern

# Patr√≥n Command | Comportamiento

Encapsula una solicitud (acci√≥n) en un objeto independiente, permitiendo desacoplar al emisor (quien pide la acci√≥n) del receptor (quien la ejecuta).
Esto facilita deshacer/rehacer, colas de comandos, logging de acciones y ejecuci√≥n diferida.

‚úÖ Pros

- Desacoplamiento: el invocador no necesita saber c√≥mo se ejecuta la acci√≥n.

- Historial / undo-redo: permite guardar y revertir acciones f√°cilmente.

- Composici√≥n flexible: comandos pueden combinarse, encolarse o ejecutarse secuencialmente.

- Reutilizaci√≥n: el mismo invocador puede ejecutar distintos comandos.

‚ùå Contras

- Sobrecarga de clases: muchos comandos ‚Üí demasiados objetos peque√±os.

- Complejidad: puede ser overkill en operaciones simples.

- Gesti√≥n de estado: si los comandos son complejos, mantener el contexto correcto se complica.

üìå Cu√°ndo usarlo

- Cuando necesitas undo/redo (editores, transacciones).

- Cuando quieres ejecutar acciones de forma diferida o en cola.

- Cuando los invocadores y receptores deben estar desacoplados.

- Cuando requieres log de operaciones o reejecuci√≥n programada.

üö´ Cu√°ndo no usarlo

- Cuando las operaciones son triviales y basta con llamar m√©todos directamente.

- En sistemas peque√±os donde la sobrecarga de comandos no compensa.

## Ejemplos empresariales

### 1) Sistemas de facturaci√≥n ‚Äî √≥rdenes de pago / facturas

#### Qu√© resuelve
Permite registrar cada acci√≥n sobre una factura (crear, aplicar descuento, anular, emitir) como objetos ejecutables, facilitando trazabilidad, reejecuci√≥n, auditor√≠a y rollback controlado.

#### Implementaci√≥n ‚Äî pasos

- Definir los commands principales (GenerarFactura, AplicarDescuento, CancelarFactura, EmitirPago) y su contrato (ej. execute(), undo() opcional).

- Dise√±ar el receiver (servicio que realiza las operaciones reales sobre facturas) y el invoker (cola/servicio responsable de ejecutar comandos).

- Decidir persistencia de comandos: almacenar en DB el command + estado (pendiente/ejecutado/failed) para auditor√≠a y reejecuci√≥n.

- Implementar manejo de errores y pol√≠ticas de retry/compensaci√≥n; registrar resultado y razones de fallo.

- A√±adir un command log con metadata (who, when, correlationId) para audit trail.

- Proveer mecanismos de undo() o comandos compensatorios (RevertirFactura) para revertir efectos.

- Tests: unidades por command, tests de integraci√≥n para secuencias y reintentos; pruebas de integridad contable.

#### Cu√°ndo usar / cu√°ndo evitar

- Usar si necesitas historial/auditor√≠a, capacidad de deshacer acciones contables o rehacer eventos fallidos.

- Evitar si el proceso es extremadamente simple y lineal sin necesidad de auditor√≠a o rollback; el overhead administrativo no compensa.

### 2) Edici√≥n de documentos corporativos (editor con undo/redo)

#### Qu√© resuelve
Encapsula acciones de edici√≥n (insertar, borrar, formato) para soportar undo/redo, macros, replay y almacenamiento incremental de cambios (operational transforms / CRDTs si es colaborativo).

#### Implementaci√≥n ‚Äî pasos

- Definir la interfaz de comando (execute(), undo(), optional mergeWith(other) para optimizaciones).

- Implementar commands b√°sicos (InsertText, DeleteText, ApplyStyle) que act√∫en sobre el receiver (document model).

- Mantener una pila de historial (undo stack) y pila de redo; almacenar suficiente contexto para undo.

- Si hay edici√≥n colaborativa, dise√±ar estrategia para transformar/combinar comandos (OT/CRDT).

- Persistencia incremental: grabar comandos (no snapshots) para reconstruir estado o para auditor√≠a.

- UI: bind de undo/redo, deshacer por acciones at√≥micas y agrupaci√≥n de comandos (batching) para UX.

- Tests: secuencias de comandos (execute ‚Üí undo ‚Üí redo), concurrencia en colaboraci√≥n y performance en historiales largos.

#### Cu√°ndo usar / cu√°ndo evitar

- Usar cuando el producto requiere undo/redo, audit trail de cambios o capacidad de replay (editores, contratos, dise√±o).

- Evitar si solo necesitas snapshots peri√≥dicos o la complejidad de mantener undo supera el beneficio (casos donde guardar versiones completas es suficiente).

### 3) Procesos de RRHH ‚Äî aprobaciones y acciones sobre solicitudes

#### Qu√© resuelve
Modela cada decisi√≥n (solicitar, aprobar, rechazar, delegar) como comando para auditar qui√©n hizo qu√©, permitir revocaciones, encolar aprobaciones y orquestar delegaciones/compensaciones.

#### Implementaci√≥n ‚Äî pasos

- Listar comandos del flujo (SolicitarVacaciones, AprobarSolicitud, RechazarSolicitud, DelegarAprobador) y contrato (execute/undo/metadata).

- Receiver: servicio de solicitudes que aplica cambios de estado en la entidad (request).

- Persistir comandos y su estado (pendiente, ejecutado, revertido) para trazabilidad y soporte.

- Integrar con workflow/orquestador: encolar comandos para aprobaci√≥n asincr√≥nica y notificar a quien corresponda.

- Implementar reglas de permisos: validar que el invocador tenga autoridad antes de ejecutar el command.

- Definir comandos compensatorios (ej. RevertirAprobacion) para escenarios de arrepentimiento o error.

- Tests de seguridad (roles), tests de flujo (encolado / reintentos) y de consistencia de estado.

#### Cu√°ndo usar / cu√°ndo evitar

- Usar en flujos con jerarqu√≠as, revisiones y donde registrar cada acci√≥n es cr√≠tico (auditor√≠a laboral, cumplimiento).

- Evitar cuando la interacci√≥n es m√≠nima y no requiere deshacer ni historial detallado; un simple cambio de estado podr√≠a bastar.

### 4) Automatizaci√≥n en e-commerce ‚Äî pipelines de pedido (agregar, procesar, cancelar)

#### Qu√© resuelve
Permite encapsular operaciones del checkout y fulfillment como comandos que se pueden encolar, reintentar, auditar y deshacer (p. ej. cancelar pedido, revertir autorizaci√≥n).

#### Implementaci√≥n ‚Äî pasos

- Definir comandos clave (AgregarAlCarrito, ConfirmarPedido, ProcesarPago, EmitirShipment, CancelarPedido) con execute() y, si aplica, undo() o compensate().

- Implementar un invoker que ejecute comandos s√≠ncronos o los encole en un broker (para procesamiento as√≠ncrono y retries).

- Persistir estado de cada command para reintentos y reconciliaci√≥n (idempotency keys).

- Dise√±ar compensaciones: comandos que revierten efectos externos (reembolsos, cancelar shipment).

- Integrar webhooks/proveedores externos: normalizar respuestas y mapear errores a estados de comando.

- Instrumentaci√≥n: logs de cada command, m√©tricas de latencia/errores y dashboards de retry/failures.

- Tests E2E con simulaci√≥n de fallos externos (pagos declined, carriers) y verificaci√≥n de compensaciones.

#### Cu√°ndo usar / cu√°ndo evitar

- Usar cuando necesitas resiliencia (retries), auditor√≠a y capacidad de compensar efectos externos (pagos, env√≠os).

- Evitar si todo es estrictamente s√≠ncrono y no hay sistemas externos ni necesidad de reintentos ni undo ‚Äî la complejidad no compensa.

## Recomendaciones finales (cu√°ndo elegir Command y riesgos)

- Elige Command cuando necesites: undo/redo, colas y retries, historial auditado de acciones, o desacoplar invocador y ejecutor (esp. con efectos externos).

- Ev√≠talo cuando las acciones son triviales, la sobrecarga de objetos/persistencia no aporta valor o la latencia/complexidad de encolado complicar√≠a el flujo.

**Riesgos comunes:** proliferaci√≥n de clases/objetos Command, dificultad para mantener contexto en undo, y complejidad de coordinar compensaciones con sistemas externos.

**Mitigaciones:** agrupar/mergear commands, definir compensate() en vez de undo() cuando sea m√°s realista, usar idempotency keys y persistir metadata suficiente para reconstruir o auditar.


### Resumen

‚ÄúEl patr√≥n Command convierte acciones en objetos: poder para ejecutar, deshacer o encolar. √ösalo cuando el control manda, ev√≠talo cuando la simpleza basta.‚Äù