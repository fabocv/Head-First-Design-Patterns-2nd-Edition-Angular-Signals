# Cap√≠tulo 3: Decorating Objects: the Decorator Pattern

## Decorator Pattern (Estructural)

El Decorator permite agregar responsabilidades a un objeto din√°micamente sin modificar su clase original ni crear una jerarqu√≠a enorme de herencias. Se envuelve el objeto en otro que implementa la misma interfaz, y que a√±ade funcionalidad antes o despu√©s de delegar la llamada al objeto original.

**‚úÖ Pros**

- Extensi√≥n flexible: puedes a√±adir funcionalidades sin tocar el c√≥digo base (OCP ‚Äì Open/Closed Principle).

- Combinaci√≥n din√°mica: puedes apilar varios decoradores en tiempo de ejecuci√≥n.

- Evita herencias profundas: reemplaza la t√≠pica explosi√≥n de subclases.

- Reutilizaci√≥n: los decoradores son modulares y se pueden combinar en distintos contextos.

**‚ùå Contras**

- Complejidad: demasiados decoradores anidados pueden dificultar entender el flujo.

- Depuraci√≥n m√°s dif√≠cil: cuesta seguir qu√© decorador aplic√≥ qu√© cambio.

- Posible sobreuso: a veces una simple composici√≥n/estrategia basta.

- No asegura orden: si el orden de los decoradores es importante, puedes introducir bugs sutiles.

### Recomendaciones para aplicar el patr√≥n

Contrato claro primero: define la interfaz base antes de a√±adir decoradores.

Documenta el orden: el orden de decoraci√≥n suele importar; hazlo expl√≠cito.

Evita anidamientos innecesarios: no crees m√°s capas de las que puedas soportar en debugging.

Instrumenta para debugging: logs/trace que indiquen la cadena de decoradores aplicada.

Tests por combinaci√≥n: unit tests para cada decorador aislado y tests de integraci√≥n para las combinaciones m√°s probables.

Feature flags y rollout: desplegar decoradores gradualmente ayuda a detectar efectos secundarios.

Fallbacks seguros: si un decorador falla, define degradaci√≥n (ej. skip logging, fallback a email si SMS falla).

## Ejemplos empresariales

### 1) Seguridad y autenticaci√≥n ‚Äî UserService decorado con Logging, Authorization, Caching

****Qu√© resuelve****: a√±adir funcionalidades transversales (log, autorizaci√≥n, cache) sin tocar el servicio core de usuarios.

#### Implementaci√≥n ‚Äî pasos

- Definir la interfaz base: qu√© m√©todos expone UserService (getUser, updateUser, etc.) y contratos (entradas/salidas/errores).

- Dise√±ar decoradores: especifica responsabilidad de cada decorador (pre-checks, post-logging, cache read/write).

- Decidir orden de envoltura: documenta la secuencia (ej. Authorization -> Caching -> Logging) y por qu√©.

- Implementar envoltura: cada decorador recibe la instancia subyacente y delega, a√±adiendo su l√≥gica antes/despu√©s.

- Configuraci√≥n runtime: activar decoradores por tenant/feature flag/env para despliegues progresivos.

- Errores y fallbacks: definir si un decorador debe fallar la operaci√≥n o degradar (ej. si cache falla, seguir sin cache).

- Observabilidad: instrumentar qu√© decoradores participaron y m√©tricas a√±adidas.

- Tests: unit para servicio desnudo y para cada decorador; tests de integraci√≥n con combinaciones cr√≠ticas.

#### Cu√°ndo usar / cu√°ndo evitar

- Usar si quieres a√±adir cross-cutting concerns sin modificar UserService.

- Evitar si la l√≥gica es simple o el overhead de capas complica debugging; si necesitas transacciones estrictas entre pasos, considerar otra estrategia.

### 2) Procesamiento de datos ‚Äî TransactionService con FraudCheckDecorator, AuditTrailDecorator

**Qu√© resuelve**: insertar validaciones y auditor√≠a alrededor del procesamiento de transacciones sin alterar el core que persiste/ejecuta la transacci√≥n.

#### Implementaci√≥n ‚Äî pasos

- Contrato de transacci√≥n: define inputs (payload, idempotency key) y outcomes (success/fail, reasons).

- Dise√±ar decoradores con side-effects controlados: FraudCheck (pre), AuditTrail (post), EnrichData (pre).

- Orden obligatorio: FraudCheck antes de persistir; AuditTrail despu√©s de confirmaci√≥n. Documenta esto.

- Idempotencia/compensaciones: decoradores respetan idempotency keys y no duplican efectos.

- Pol√≠tica de manejo de fraude: decidir rechazo vs encolamiento para revisi√≥n manual.

- Testing de escenarios cr√≠ticos: fraude detectado, retries, y comportamiento en fallos parciales.

- Monitorizaci√≥n y alertas: m√©tricas de rejections, latencias introducidas y volumen de auditor√≠a.

- Privacidad: enmascarar datos sensibles en logs/audits.

#### Cu√°ndo usar / cu√°ndo evitar

- Usar para a√±adir checks/auditor√≠a sin tocar el core de negocio.

- Evitar si necesitas transaccionalidad at√≥mica entre check y persistencia (aqu√≠ la soluci√≥n suele requerir orquestador o transacci√≥n coordinada).

### 3) Notificaciones / Mensajer√≠a ‚Äî Notifier b√°sico decorado con Sms, Push, Slack

**Qu√© resuelve**: permitir m√∫ltiples canales de notificaci√≥n componibles sin duplicar la l√≥gica de notificaci√≥n core.

#### Implementaci√≥n ‚Äî pasos

- Contrato √∫nico de notificaci√≥n: canonical notify(target, payload) y resultado esperado.

- Core notifier: implementa env√≠o base (por ejemplo email).

- Decoradores por canal: cada decorador a√±ade un canal (SMS, Push, Slack) y delega al core.

- Pol√≠tica de preferencia: usar decoradores condicionales basados en preferencias del usuario o configuraci√≥n.

- Retries/Backoff: cada decorador define su pol√≠tica; evitar bloquear el core request (usar colas para canales lentos).

- Idempotencia: usar keys para evitar duplicados en reintentos.

- M√©tricas por canal: √©xito, fallos y latencia.

- Tests E2E: flujos multi-canal y simulaci√≥n de fallos en proveedores.

#### Cu√°ndo usar / cu√°ndo evitar

- Usar cuando m√∫ltiples canales se combinan din√°micamente y quieres reusar el core.

- Evitar si la orquestaci√≥n entre canales requiere transacciones fuertes o ordering estricto.

### 4) Facturaci√≥n ‚Äî PriceCalculator decorado con Discount, Tax, Fee

**Qu√© resuelve**: aplicar m√∫ltiples ajustes al precio (descuentos, impuestos, cargos) de forma modulable y auditables.

#### Implementaci√≥n ‚Äî pasos

- Definir modelo base: inputs (items, customer, locale), salida (subtotal, impuestos, total).

- Crear decoradores con responsabilidad √∫nica: DiscountDecorator, TaxDecorator, FeeDecorator.

- Orden legal y de negocio: documenta si impuesto se calcula sobre subtotal o sobre subtotal menos descuento.

- Versionado de reglas: mantener reglas/versiones para reproducibilidad del c√°lculo.

- Transparencia: cada decorador debe producir descriptor legible para factura (qu√© aplic√≥ y por qu√©).

- Rounding y contabilidad: definir reglas de redondeo coherentes con ERP/contabilidad.

- Tests financieros: escenarios combinados, l√≠mites legales y multi-jurisdicci√≥n.

- Auditor√≠a: registrar qu√© decoradores actuaron y sus valores para soporte/regulaci√≥n.

#### Cu√°ndo usar / cu√°ndo evitar

- Usar cuando las reglas de c√°lculo son modulares y cambian con frecuencia.

- Evitar si el c√°lculo es simple y fijo; usar composici√≥n excesiva puede complicar conciliaci√≥n contable.

### 5) UI (Angular/Frontend) ‚Äî componente base decorado con accesibilidad, tracking, estilos din√°micos

**Qu√© resuelve**: a√±adir features UI (a11y, tracking, theming) reutilizables sin reescribir cada componente.

#### Implementaci√≥n ‚Äî pasos

- Definir contrato del componente base: inputs/outputs, events y lifecycle claramente documentados.

- Decidir la t√©cnica de ‚Äúdecorator‚Äù en frontend: wrapper components, directives, higher-order components, o composition via services.

- **Dise√±ar decoradores UI**:

- - **AccessibilityDecorator**: a√±ade ARIA, keyboard handlers.

- - **TrackingDecorator**: hook en eventos para enviar m√©tricas.

- - **ThemingDecorator**: aplica clases/variables CSS seg√∫n config.

- Isolation & non-invasive API: decoradores no deben alterar la API p√∫blica del componente, solo extender comportamiento.

- Orden y prioridades: especificar c√≥mo interact√∫an (ej. theming antes de rendering, tracking conectado a eventos luego de accesibility handlers).

- Lazy-load y performance: cargar tracking libs o skins de manera lazy para no inflar bundles iniciales.

- Testing visual y de accesibilidad: snapshots, tests con axe-core, interacci√≥n keyboard.

- Feature flags & rollout: activar decoradores por entorno, roles o A/B testing.

- Observabilidad: m√©tricas de impacto en render y errores introducidos por decoradores.

- Fallbacks: si un decorador falla (tracking), degradar sin romper la UI.

#### Cu√°ndo usar / cu√°ndo evitar

- Usar si quieres aplicar cross-cutting UI concerns en muchos componentes y mantener DRY.

- Evitar si la capa de envoltura a√±ade latencia perceptible o complica la accesibilidad; si solo pocos componentes necesitan la mejora, aplica directamente all√≠.

> ### üìå Regla de oro
> Usa Decorator cuando necesites acumular responsabilidades din√°micamente.