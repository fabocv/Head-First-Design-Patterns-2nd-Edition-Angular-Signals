# CapÃ­tulo 5: One-of-a-Kind Objects: the Singleton Pattern

# Singleton Pattern | Creacional

El Singleton asegura que exista una Ãºnica instancia de una clase en toda la aplicaciÃ³n y proporciona un punto global de acceso a ella.

âœ… Pros

- Control Ãºnico de recursos compartidos (DB, logger, cache).

- Menos memoria: no se crean mÃºltiples instancias innecesarias.

- FÃ¡cil acceso: cualquier parte del sistema puede usarlo sin pasarlo como dependencia.

- Consistencia global: todos usan el mismo estado.

âŒ Contras

- Acoplamiento oculto: partes del cÃ³digo dependen del mismo estado global.

- DifÃ­cil de testear: los tests pueden contaminarse si la instancia mantiene estado.

- ViolaciÃ³n de SRP: a veces combina demasiadas responsabilidades.

- Riesgo de abuso: se usa como â€œatajoâ€ en lugar de aplicar inyecciÃ³n de dependencias.

## Ejemplos empresariales 

1) Gestor de configuraciÃ³n central (ConfigManager)

**QuÃ© resuelve**: un Ãºnico punto que carga y expone la configuraciÃ³n de la app (endpoints, flags, timeouts), evitando lecturas/valores inconsistentes repartidos.

#### ImplementaciÃ³n â€” pasos

- Alcance y lectura inicial: decidir quÃ© se carga al inicio (env vars, vault, archivos, remote config).

- Crear la clase singleton: instancia Ãºnica que carga la config al boot y la expone como read-only o con mÃ©todos controlados de actualizaciÃ³n.

- Fuente segura de secretos: integrar vault/secret-manager para credenciales; no almacenar en texto plano.

- Reload/refresh: diseÃ±ar cÃ³mo y cuÃ¡ndo se actualiza la config (hot-reload, polling, webhook de actualizaciÃ³n).

- API de acceso: exponer getters con validaciÃ³n y valores default; evitar setters globales que rompan inmutabilidad inesperada.

- Fallbacks y defaults: si falla la carga remota, usar defaults predefinidos y modo degradado.

- Tests: unit tests para carga inicial y escenarios de refresh; tests de integraciÃ³n con mock de vault.

- Observabilidad: logs en la carga/refresco y mÃ©tricas de fallos de carga.

- DocumentaciÃ³n: cÃ³mo aÃ±adir nuevas claves, y runbook si la config falla en producciÃ³n.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar si necesitas una Ãºnica fuente de verdad de configuraciÃ³n en toda la app.

- Evitar si cada tenant necesita su propia config aislada (mejor un registry por tenant) o si tu app es trivial y la complejidad no compensa.

### 2) Logger centralizado (AppLogger)

**QuÃ© resuelve**: un logger consistente con formato, destinos (fichero, remote, monitoring) y polÃ­ticas de rotaciÃ³n que todas las piezas del sistema usan.

#### ImplementaciÃ³n â€” pasos

- Definir contract: niveles (error, warn, info, debug), formato (JSON), fields mÃ­nimos (timestamp, service, correlationId).

- Crear instancia singleton: instancia global que inicializa transportes (file, stdout, external collector).

- ConfiguraciÃ³n de sinks: elegir destinos y samplers (env: dev->console, prod->remote).

- Context propagation: API para inyectar contexto (requestId, userId) sin mutar global state.

- Log rotation y retention: polÃ­tica de rotaciÃ³n y borrado; integrar con storage/archiving.

- Performance: non-blocking I/O, buffering y backpressure; sampling para high-volume logs.

- Tests: asegurar formato, niveles y transporte; tests de fallos en sink (degradaciÃ³n).

- Seguridad: sanitizar PII en logs y polÃ­ticas de access control sobre logs sensibles.

- Observabilidad: mÃ©tricas de logs emitidos por nivel y errores en envÃ­o.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar cuando necesitas coherencia en logging y facilidad para instrumentar toda la plataforma.

- Evitar si cada mÃ³dulo requiere loggers radicalmente distintos y la opciÃ³n centralizada se vuelve restrictiva â€” entonces permitir configuraciÃ³n por mÃ³dulo.

### 3) Pool de conexiones a base de datos (DBConnectionPool)

**QuÃ© resuelve**: administrar un Ãºnico pool central para evitar creaciÃ³n descontrolada de conexiones y optimizar recursos.

#### ImplementaciÃ³n â€” pasos

- Definir contract del pool: acquire, release, healthCheck, tamaÃ±o mÃ¡ximo y timeouts.

- Instancia singleton: centraliza la creaciÃ³n y gestiÃ³n del pool al iniciar la aplicaciÃ³n.

- ConfiguraciÃ³n tunable: max connections, idle timeout, retry policy por env.

- Manejo de fallos: circuit breaker / reconnect logic y fallback (modo degradado read-only).

- InstrumentaciÃ³n: mÃ©tricas de uso del pool (active, idle, waits) y alertas de agotamiento.

- Close-on-shutdown: liberar conexiones al apagar la app de forma ordenada.

- Tests: tests de concurrency, saturaciÃ³n y timeouts usando entornos aislados.

- Seguridad: credenciales rotadas y uso de roles/identidades cuando aplica.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar cuando mÃºltiples mÃ³dulos comparten la misma DB y necesitas control central de conexiones.

- Evitar si cada componente conecta a DBs completamente diferentes y no hay beneficio de compartir pool; en microservicios, preferir pool por servicio.

### 4) Servicio de cache en memoria (CacheService)

**QuÃ© resuelve**: proveer un cache compartido en proceso para datos frecuentemente leÃ­dos (config, lookups), evitando duplicar estado y cache inconsistentes.

#### ImplementaciÃ³n â€” pasos

- Definir polÃ­ticas: TTL, eviction strategy (LRU), tamaÃ±o mÃ¡ximo en memoria.

- Instancia singleton: Ãºnica cache en proceso expuesta vÃ­a API (get, set, delete, has).

- Backplane (opcional): si hay mÃºltiples instancias, integrar pub/sub para invalidaciones (coherencia).

- Observabilidad: mÃ©tricas (hits, misses, evictions) y logs de comportamiento.

- Persistencia opcional: backing store (Redis) si la cache debe sobrevivir reinicios.

- Seguridad: cuidado con PII y enmascaramiento en logs; control de quiÃ©n puede poblar la cache.

- Tests: behaviour under load, eviction correctness, and invalidation propagation.

- Shutdown behavior: flush opcional o persistencia segÃºn necesidad.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar para mejorar latencia de lectura de datos que son costosos de calcular o fetch.

- Evitar como Ãºnica fuente de verdad en entornos distribuidos sin backplane; no confÃ­es en cache singleton para persistencia crÃ­tica.

### 5) Gestor de sesiones activas (SessionManager)

**QuÃ© resuelve**: llevar registro central de sesiones activas, tokens revocados, o lÃ­mites de sesiÃ³n por usuario.

#### ImplementaciÃ³n â€” pasos

- Definir modelo de sesiÃ³n: campos necesarios (sessionId, userId, lastSeen, metadata).

- Singleton manager: instancia que registra sesiones en memoria o via backing store.

- IntegraciÃ³n con auth: API para crear/validate/destroy session y revocar tokens.

- Escalabilidad: si hay mÃºltiples instancias, almacenar en store central (Redis) y usar singleton como facade local + cache.

- PolÃ­ticas: expirations, concurrent session limits, forced logout.

- Security: revocations, refresh token handling, and detection of suspicious activity.

- Observabilidad & audit: logs de creaciÃ³n/destrucciÃ³n y mÃ©tricas de sesiones activas.

- Tests: concurrency, revocation, and failover behaviour.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar si necesitas un control central de sesiones (single sign-out, limits, revocations).

- Evitar si la app es serverless y las sesiones se delegan totalmente a JWT stateless sin revocation (en ese caso un store central puede ser mejor que singleton en proceso).

## Recomendaciones transversales â€” cuÃ¡ndo usar Singleton y riesgos

### Usar Singleton cuando

- Hay un recurso Ãºnico y compartido que realmente debe existir una sola vez por proceso (config loader, pool, logger).

- Necesitas control central de inicializaciÃ³n y lifecycle del recurso.

### Evitar Singleton cuando

- El patrÃ³n se usa como atajo para estado global que deberÃ­a inyectarse (inversiÃ³n de control / DI).

 - Quieres testabilidad aislada (mocks y resets son mÃ¡s difÃ­ciles con singletons globales).

- En arquitecturas distribuidas se confÃ­a en singletons in-memory como fuente Ãºnica (no escala ni es duradero).

### Riesgos y mitigaciones

- Acoplamiento implÃ­cito: documenta el uso y prefiere inyecciÃ³n donde sea posible.

- Test pollution: proporcionar mÃ©todos de reset o usar factories en tests para aislar instancias.

- Concurrencia: asegurar thread/process safety en creaciÃ³n y acceso si aplica (locks, atomics).

- Estado mutable global: minimizar mutabilidad; preferir readonly o operaciones controladas.

- Escalabilidad: si necesitas coherencia entre procesos, aÃ±ade backing stores o patterns distribuidos (leader election, distributed lock).

> ### ðŸ“Œ Regla de oro:
>
>El Singleton no es un martillo para todo. Ãšsalo solo cuando exista un recurso Ãºnico y centralizado en la empresa (config, cache, logger, pool de conexiones).