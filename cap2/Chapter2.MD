## CapÃ­tulo 2: Keeping your Objects in the Know: the Observer Patterns

# PatrÃ³n Observer | Comportamiento

**PropÃ³sito:** define una relaciÃ³n uno a muchos entre objetos. Cuando un objeto (â€œsujetoâ€) cambia de estado, notifica automÃ¡ticamente a sus â€œobservadoresâ€.

**Idea clave:** desacoplar el emisor de eventos (subject) de los receptores (observers).

### Usos tÃ­picos:

Sistemas de eventos (UI, Angular signals, RxJS observables).

ComunicaciÃ³n entre componentes sin acoplarlos directamente.

Modelar flujos reactivos o pub-sub.

### âœ… Pros

- Desacoplamiento fuerte â†’ el subject no necesita saber quiÃ©n lo escucha.

- Escalabilidad â†’ puedes agregar o quitar observadores sin tocar el subject.

- Extensibilidad â†’ permite crear sistemas reactivos y plugin-based.

- Natural para GUIs y flujos asÃ­ncronos â†’ base de eventos en Angular, React, etc.

### âŒ Contras

- Orden de notificaciÃ³n no garantizado â†’ los observers se notifican, pero no hay control fuerte sobre el orden ni sobre fallos de uno afectando a otros.

- DifÃ­cil de depurar â†’ las cadenas de eventos pueden generar efectos secundarios no obvios (Â¿quiÃ©n me notificÃ³?).

- Posible sobrecarga de eventos â†’ muchos observadores = mucho overhead, incluso si no hacen nada Ãºtil.

- Fugas de memoria â†’ si un observer no se desuscribe, puede quedar en memoria (clÃ¡sico bug en Angular/RxJS).

- Complejidad accidental â†’ para escenarios simples, un callback directo es mÃ¡s claro que un sistema Observer formal.


## Ejemplos empresariales del Observer

#### Sistema de notificaciones internas

Un servicio central emite eventos (p. ej. user.created, order.shipped) y mÃºltiples consumidores reaccionan: email, Slack, registro en DB.

#### ActualizaciÃ³n de cachÃ©s distribuidas

Cuando un recurso cambia (ej. producto actualizado), el subject notifica para invalidar/actualizar caches en servicios y CDNs.

#### Monitoreo / TelemetrÃ­a en tiempo real

Un componente emite mÃ©tricas y errores; varios observadores consumen para dashboards, alertas y almacenamiento histÃ³rico.

#### Workflows y orquestaciÃ³n de procesos

Un motor de workflow emite etapas (task.completed, approval.granted) y distintos microservicios reaccionan (siguiente tarea, notificar, auditar).

## CÃ³mo usar el patrÃ³n Observer para cada ejemplo (pasos prÃ¡cticos)

### 1) Sistema de notificaciones internas (event bus para eventos del negocio)

**QuÃ© resuelve**: un servicio publica eventos (p. ej. user.created, order.shipped) y mÃºltiples consumidores reaccionan: email, Slack, tareas asÃ­ncronas, logs.

#### ImplementaciÃ³n â€” pasos

- Definir el catÃ¡logo de eventos: lista de eventos con esquema mÃ­nimo (type, timestamp, payload, correlationId).

- Implementar el Subject (publisher): componente que emite eventos. Puede ser una librerÃ­a interna o un endpoint que publica al bus.

- Elegir transporte: local in-memory (app monolito) o broker (Kafka, SNS, Rabbit) segÃºn escala y durabilidad.

- Implementar observers: EmailService, SlackNotifier, ActivityLogger, AnalyticsPublisher que suscriben y procesan eventos.

- Registro dinÃ¡mico: permitir registrar/desregistrar observers por config/feature flags.

- Manejo de fallos: observers deben procesar con retries y DLQ sin bloquear al publisher.

- Tracing: propagar correlationId para seguir la cadena entre servicios.

- Pruebas: unit tests del publisher y mocks para cada observer; integraciÃ³n con broker en staging.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar si hay mÃºltiples reacciones independientes a los mismos hechos del negocio y quieres bajo acoplamiento.

- Evitar si hay sÃ³lo un consumidor o si necesitas transacciones estrictas (el patrÃ³n no garantiza transaccionalidad entre subject y observers).

### 2) ActualizaciÃ³n de cachÃ©s distribuidas (invalidate/update caches)

**QuÃ© resuelve:** cuando se actualiza una entidad, notificar a cachÃ©s locales, Redis y CDNs para invalidar o refrescar.

#### ImplementaciÃ³n â€” pasos

- Definir quÃ© cambios disparan eventos: create/update/delete y quÃ© keys/patterns afectan.

- Emitir evento desde la fuente de verdad: al persistir, publicar entity.updated { entityId, version, keys }.

- Transport layer: usar pub/sub o broker para garantizar entrega a instancias distribuidas.

- Observers de cache: workers que invalidan keys en caches locales, en Redis y solicitan purge a CDN.

- Versioning/optimistic checks: incluir version para evitar stale invalidations (race conditions).

- Retries y monitorizaciÃ³n: reintentos y mÃ©tricas de latencia/invalidation success.

- Pruebas de consistencia: verificar que tras evento los hits/misses cambian como esperado.

### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar cuando tu arquitectura es distribuida y necesitas propagar invalidaciones sin acoplar servicios.

- Evitar si la consistencia debe ser fuerte y sÃ­ncrona (en ese caso, lock / transacciÃ³n con cache-coherent strategy es preferible).

### 3) Monitoreo/telemetrÃ­a en tiempo real (producers â†’ collectors)

**QuÃ© resuelve:** emisores ligeros (apps) publican mÃ©tricas/errores; mÃºltiples consumidores procesan: Prometheus, ELK, alerting, BI.

#### ImplementaciÃ³n â€” pasos

- Catalogar mÃ©tricas y eventos: tipos (counter, gauge, trace, error), etiquetas estÃ¡ndar (service, env, host).

- Subject ligero en apps: librerÃ­a no bloqueante que publica eventos/metrics (UDP, agent, HTTP batch).

- Observers especializados: MetricsCollector, LogForwarder, AlertEngine que consumen y persisten/alertan.

- Batching y sampling: agrupar o muestrear para reducir load en collectors.

- QoS y backpressure: degradaciÃ³n (mÃ¡s sampling) si collectors se saturan.

- Enriquecimiento central: subject agrega contexto (correlationId, version) para todos los observers.

- Tests y SLAs: pruebas de volumen y reglas de alerta.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar si necesitas observabilidad modular y escalable con mÃºltiples sinks.

- Evitar si solo necesitas logs simples locales; el overhead no compensa en apps pequeÃ±as.

### 4) OrquestaciÃ³n coreogrÃ¡fica de workflows (etapas â†’ acciones independientes)

**QuÃ© resuelve:** motor emite etapas del proceso (task.completed, approval.granted) y microservicios reaccionan para avanzar, auditar o compensar.

#### ImplementaciÃ³n â€” pasos

- Modelar eventos de workflow: definir payloads (workflowId, step, status, context).

- Emitir eventos desde el motor: cada cambio de estado publica el evento.

- Observers de acciÃ³n: microservicios que encolan la siguiente tarea, envÃ­an notificaciones o registran auditorÃ­a.

- Idempotencia en observers: diseÃ±ar observers para tolerar reentregas (idempotency keys).

- Versionado de eventos: soportar cambios futuros en pasos/estructura del payload.

- Circuit breakers & compensations: observers deben poder disparar compensaciones si falla un paso crÃ­tico.

- SimulaciÃ³n y tests de resiliencia: pruebas de reentrega, latencia y fallos parciales.

#### CuÃ¡ndo usar / cuÃ¡ndo evitar

- Usar para coreografÃ­a distribuida donde queremos aÃ±adir pasos sin cambiar el coordinador central.

- Evitar si el flujo requiere un control secuencial estricto y transaccional (entonces orquestador central es mejor).

## Recomendaciones generales â€” cuÃ¡ndo elegir Observer y riesgos

**Elegir Observer cuando:** varios consumidores independientes deben reaccionar a los mismos eventos y quieres bajo acoplamiento y facilidad para extender funcionalidad.

**No elegir cuando**: necesitas transacciones ACID entre emisor y receptor, orden estricto de ejecuciÃ³n o sÃ³lo hay un consumidor.

**Riesgos comunes:**

- Debugging complejo: instrumenta con correlationId y trazabilidad.

- Fugas de memoria: en procesos in-memory, asegurar unsubscribe en lifecycle.

- Inconsistencias por reentregas: diseÃ±ar idempotencia y versioning.

- SaturaciÃ³n: usar batching, sampling y backpressure.

**Mitigaciones:** usar brokers (durabilidad), establecer SLA de eventual consistency, instrumentaciÃ³n y DLQ/retries, y pruebas de caos.


>### ðŸ“Œ Regla de oro
>
>Ãšsalo cuando varios objetos dependan de otro, y no quieras acoplarlos.
>
>EvÃ­talo cuando haya solo un consumidor, o cuando el ciclo de vida de los observers sea difÃ­cil de controlar.
>
>En Angular â†’ prefiere signals y RxJS bien gestionados con takeUntil o async pipe para evitar fugas.
